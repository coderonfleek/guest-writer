---
layout: post
title: "State Management in Vue Apps using Vuex"
description: "Managing state in Vuejs Applications using the Vuex flux library"
date: "2018-09-19 08:30"
author:
  name: "Fikayo Adepoju"
  url: "coderonfleek"
  mail: "fik4christ@yahoo.com"
  avatar: "https://twitter.com/coderonfleek/profile_image?size=original"
related:
  - 2017-11-15-an-example-of-all-possible-elements
---

**TL;DR:** As [Single Page Applications](https://en.wikipedia.org/wiki/Single-page_application) (SPA) are fast becoming the de facto way of developing Frontend applications, one of the major issues faced implementing an SPA is how we manage state between all the components spread around our application. Vuejs Apps are not an exception to this. However, a few neat flux libraries like [Redux](https://redux.js.org/) have risen to solve this problem. The Vuejs team has also jumped on the flux train and come up with [Vuex](https://vuex.vuejs.org/) which is a state management pattern + library for Vue.js applications. In this article, we are going to be learning how to manage state in Vuejs applications using Vuex by building a simple application with Vue and Vuex.

## Prerequisites

Before you begin going through this article, there are a few things you should already be familiar with, at least at a basic level.

1. [Nodejs](https://nodejs.org) and NPM Installed on your computer
2. Javascript ES6 (ES2015)
3. [Vuejs](https://vuejs.org/)

## Introducing Vuex

Vuex is a state management pattern and library for Vuejs applications built on the concept of unidirectional data flow which is the [Flux](https://facebook.github.io/flux/docs/overview.html) pattern of managing state. It helps build and manage a centralized store which holds the entire state of the application, thus, any component connected to this store gets updated as the state gets updated. Vuex also ensures that the state of the application is mutated in a predictable fashion making it easier to track changes and debug issues.

### Vuex Concepts

![Vuex Architecture](https://vuex.vuejs.org/vuex.png)

The concept Vuex works with is to have components or server responses from a Backend API raise events (Actions). These actions then cause the state (contained in the central store) to be mutated through a defined set of rules (Mutations), the resultant change in state is then reflected in any component connected to the Vuex store.

### Vuex Store

The Vuex store is responsible for holding and managing our application state. It defines the state of the application and methods of mutating and retreiving state. The state is a single object which contains all our application level state and is the single source of truth in our application.
To create a new Vuex store, we need to call the `Store` constructor of the Vuex module and pass in our store configuration object.

```javascript
const store = new Vuex.Store({
  ....
})
```

Our store configuration object will hold definitions for our application state, mutations, actions and other store properties for managing and retrieving the application state.

Let's assume we have a list of students in our application. We want to be able to display the students list, add a new student to the list and remove a student when they leave the hypothetical program. We can simply represent our student's list in our application state thus:

```javascript
const store = new Vuex.Store({
  state: {
    students: [
      {
        id: 1,
        name: "Fikayo Adepoju"
      },
      {
        id: 2,
        name: "Elon Musk"
      },
      {
        id: 3,
        name: "Serena Williams"
      }
    ]
  }
});

export default store;
```

Lets call the file above `store.js`

To retrieve application state from our store for use in our components, we can simply import our store into our component. Because Vuex stores are reactive, the way we retrieve state from the store is by returning some part of our store state from computed properties of our component

```javascript
import store from "./store";

const StudentList = {
  template: `
  <ul>
    <li v-for="student in students">{{student.name}}</li>
  </ul>
  `,
  computed: {
    students() {
      return store.state.students;
    }
  }
};
```

In a multi-component Vue application (which is most of the time the case), Vuex offers a way for us to inject our store into a parent component and through this all its child components automatically have the store injected into them. With this, we don't have to import the store into every component file that requires it.

To set this up, we first need to configure Vue to "use" Vuex. We can simply do this in our store file thus:

```javascript
import Vue from "vue";
import Vuex from "vuex";

//Configure Vuex for modules
Vue.use(Vuex);

const store = new Vuex.Store({
  ....
})
```

With this setup, we can simply import our store into a root component thus:

```javascript
import store from "./store";

export default {
  name: "app",
  store,
  components: {
    StudentList,
    StudentProfile,
    ....
  },
  .....
}
```

In the above, the child components (StudentList, StudentProfile etc. in this case) simply inherit the store from the root "app" component, they can then access the store from the `$store` object (not `store` as previously used in the `StudentList` component), while the root component uses the `store` object

```javascript
import store from "./store";

const StudentList = {
  ......
  ,
  computed: {
    students () {
      return this.$store.state.students
    }
  }
}
```

### Vuex Mutations

[Mutations](https://vuex.vuejs.org/guide/mutations.html) serve as the only way to change state in a Vuex store. They operate similar to events and event handlers. They have a name which is known as the `type` of the mutation sort of like an event name, and a function which is the handler for the mutation type. The handler receives the current state as its first argument and performs change operations on it.

Mutations can also receive a second (optional) argument which contains a payload of data needed in making state changes.

Mutations are defined in an object assigned to the `mutations` property of the Vuex store configuration object.

Let's assume we want to update our students list by adding a new student to the list, we can simply define an `ADD_STUDENT` mutation type and write an handler for it thus:

```javascript
const store = new Vuex.Store({
  ....
  mutations: {
    ADD_STUDENT (state, new_student_data) {
      // add new student
      state.students.push(new_student_data);
    }
  }
})
```

In Vuex, you can't call mutation handlers directly. Just like event handlers, mutations need to be triggered for their handlers to run, this "triggering" is done by calling `store.commit` with the respective mutation type

```javascript
.....

methods : {
  add_new_student: () => {
    store.commit("ADD_STUDENT", student_data);
  }
}
.....
```

This will call the mutation handler for the `ADD_STUDENT` mutation type with `student_data` as the payload.

### Vuex Actions

[Actions](https://vuex.vuejs.org/guide/actions.html) are very similiar to Mutations. In Vuex, Mutations can only be used for synchronous operations meaing that you cannot make api calls within them or perform any asynchronous operations. For asynchronous operations, we use Actions instead.
An Action recieves a context object, this object consists of the same methods and properties that can be found on the store itself e.g `commit`, `state` etc.

Thus, actions can change the state directy and also commit mutations. Let's assume we need to fetch our students list from some backend api, the action implementation for such operation can read thus:

```javascript
actions: {
  load_users (context) {
    // call api to get users
    axios.get(
      "https://jsonplaceholder.typicode.com/users"
      )
      .then(
        // handle success
        (res) => context.commit("LOAD_USERS", res.data),
        // handle failure
        (err) => context.commit("HANDLE_ERROR", err)
      )
  }
}
```

The code above makes an api call to a backend api to fetch students, then commits the mutation that's responsible for updating our state with the list of students by passing it the response data from the backend api. It also handles the error situation by commiting another mutation that handles errors. This would not work if we had used a Mutation instead of an Action.

Actions are a really powerful part of Vuex with more features than has been described here. For more details on Actions check the [Vuex documentation](https://vuex.vuejs.org/guide/actions.html).

### Using Vuex Getters

Sometimes we would like to return some parts of our state pre-processed (e.g. return date in a particular format) or return a computed value or a default for a null state property, [Getters](https://vuex.vuejs.org/guide/getters.html) enable us do this. Getters are simply functions that receive the state as argument and return a computed property.

Let's assume we need to use/display the number of students in our application in several components, we won't want to write the code to count the number of students in the state in each component that requires this. We can simply create a getter in our store that returns the number of students currently in our state.

```javascript
const store = new Vuex.Store({
  state: {
    students: [
      ...
    ]
  },
  getters: {
    numberOfStudents: state => {
      return state.students.length;
    }
  }
});
```

Getters can then be accessed on the `store.getters` object using property-style access:

```javascript
store.getters.numberOfStudents;
```

If the component is the child of the root component that imports the store, you can access getters from `this.$store.getters` e.g.:

```javascript
this.$store.getters.numberOfStudents;
```

You can also access a getter within another getter by passing `getters` as the second argument to the getter inside which you want to reference another getter.

```javascript
getters: {
  // ...
  studentsCountMessage: (state, getters) => {
    return `The total students number of students are : ${getters.numberOfStudents}`;
  };
}
```

## Vue and Vuex in Action

### What we would be building

![Vue Vuex Bitcoin Dashboard](images/bitcoin-dashboard.gif)

With our newly acquired knowledge of Vuex, we will be building a simple Bitcoin dashboard that shows the current price of Bitcoin and updates the price, percentage increase and price difference of Bitcoin in real-time throughout all its components. It also shows the history of previous prices up to four price changes ago.

NB: These are faked Bitcoin prices generated by the application. Thanks.

### Creating a new Vue App

We will be creating a new Vue application using the [Vue CLI](https://cli.vuejs.org/), so if you don't have the cli already installed, run the following command:

`npm install -g @vue/cli`

After a successfull installation, simply navigate to the directory in which you want to keep your project and run the command below to create a new Vuejs app named `bitcoin-dashboard`.

`vue create bitcoin-dashboard`

This will prompt you to select a preset, select the `default` by hitting `Enter`. This will then create our new project. Enter into the project root by running `cd bitcoin-dashboard` then run the following command to serve your Vuejs application in the browser.

`npm run serve`

You can always shutdown the server by running `Ctrl + C`.

### Installing Dependencies

For our project, we are going to be installing three (3) dependencies which are [Bootstrap](https://getbootstrap.com), Vuex and [Font Awesome](https://fontawesome.com/) (the free version) as a development dependency.
To install these, run the following commands below:

`npm install bootstrap vuex --save`

`npm install @fortawesome/fontawesome-free --save-dev`

### Setting up the Vuex Store

To begin setting up our store, create a folder named `store` inside your `src` folder, this folder will contain all files related to our store.
We first need a set of fake prices to begin with, this is not really necessary but we want to be able to see some prices as we load the application, other prices will then be generated dynamically. So create a file named `prices.js` and add the code below:

```javascript
const prices = [
  {
    amount: 7322.89,
    timestamp: 1536750195889
  },
  {
    amount: 6322.02,
    timestamp: 1536750173761
  },
  {
    amount: 5222.64,
    timestamp: 1536750028203
  },
  {
    amount: 5242.61,
    timestamp: 1536750028150
  }
];

export default prices;
```

In the file above we export an array of Bitcoin prices history and the time each price was set.

Next thing is to create a file where we store our Vuex actions for the application. Create a file named `actions.js` and add the following code:

```javascript
const actions = {
  UPDATE_PRICE: "UPDATE_PRICE"
};

export default actions;
```

This file only contains one action because that is the only action we need in our application. Having our actions in a separate file this way helps organize our code better and prevents duplicating string names across our application.

Now we can create our store, create a file named `index.js` to hold our store. Add the following code into the file:

```javascript
import Vue from "vue";
import Vuex from "vuex";
import prices from "./prices";

//Configure Vuex for modules
Vue.use(Vuex);

const store = new Vuex.Store({
  state: {
    prices: prices
  },
  getters: {
    currentPrice: state => {
      return state.prices[0];
    },
    previousPrice: state => {
      return state.prices[1];
    },
    percentageIncrease: (state, getters) => {
      const currentAmount = getters.currentPrice.amount;
      const previousAmount = getters.previousPrice.amount;
      return (
        ((currentAmount - previousAmount) / previousAmount) *
        100
      ).toFixed(2);
    },
    difference: (state, getters) => {
      const currentAmount = getters.currentPrice.amount;
      const previousAmount = getters.previousPrice.amount;
      return (currentAmount - previousAmount).toFixed(2);
    }
  },
  mutations: {
    UPDATE_PRICE(state, payload) {
      let newPricing = payload;

      // remove the oldest price
      state.prices.pop();

      // add the new price
      state.prices = [newPricing, ...state.prices];
    }
  }
});

export default store;
export { default as actions } from "./actions";
```

There is a lot going on in this file, so let's drill into it gradually. First we import all modules required. Then we configure Vue to use Vuex for modules with this line:

```javascript
Vue.use(Vuex);
```

We then instantiate a new Vuex store with the configuration object where all our settings are declared.
In the configuration object, we first set our `state` object with the prices data.

```javascript
state: {
  prices: prices;
}
```

Then we create a set of `getters` to compute and return the current bitcoin price (`currentPrice`), previous bitcoin price (`previousPrice`), percentage difference between the current price and previous price (`percentageIncrease`) and the difference between the current and previous price (`difference`).

Next we create our `mutations`. In this application we only need one mutation which would update the price of Bitcoin.

```javascript
  mutations: {
    UPDATE_PRICE(state, payload) {
      let newPricing = payload;

      // remove the oldest price
      state.prices.pop();

      // add the new price
      state.prices = [newPricing, ...state.prices];
    }
  }
```

The `UPDATE_PRICE` mutation receives the new price data in its payload, removes the oldest price from the prices array and inserts a new one at the beginning of the array.

That's it! Our store is fully complete. All we need to do now is to export our `store` and also export our `actions` which is done with the following lines:

```javascript
export default store;
export { default as actions } from "./actions";
```

### Creating the store-connected Components

Now that our store is all set and ready to go, let's create our application components that will connect to our store for updates.

#### CoinPrice Component

This is the component that will display the current Bitcoin price and the difference between the previous and current price.

![CoinPrice component](images/coinprice.png)

Go into the `src/components` folder and delete the default `HelloWorld.vue` that comes with the scaffolded project, then create a file named `CoinPrice.vue` and add the following code:

```markup
<template>
  <div id="counter" class="bg-success text-white">
    <div class="row p-3">
      <div class="col-2">
        <i class="fas fa-dollar-sign fa-4x"></i>
      </div>
      <div class="col-10 text-right">
        <h2>{{format(price.amount)}}</h2>
        ${{difference}}
      </div>
    </div>
  </div>
</template>

<script>
  export default {
    name: "CoinPrice",
    computed: {
      price() {
        return this.$store.getters.currentPrice;
      },
      difference() {
        return this.$store.getters.difference;
      }
    },
    methods: {
      format: price => {
        return price.toFixed(2);
      }
    }
  };
</script>
```

In the code above we create the `CoinPrice` Vue component with two computed properties to help us retrieve state from our store. We also add a `format` method to return a cleaner price for display in our component template.

#### PercentChange Component

This is the component that will display the percentage difference between the current and previous Bitcoin prices and also display the time the last update was made.

![PercentageChange Component](images/percentchange.png)

Create a new file, still inside your components directory, and name it `PercentChange.vue`. Now enter the following code into the file:

```markup
<template>
  <div id="counter" class="bg-primary text-white">
    <div class="row p-3">
      <div class="col-2"><i class="fas fa-percent fa-4x"></i></div>
      <div class="col-10 text-right">
        <h2>
          {{percentageIncrease}}<small>%</small>
        </h2>
        {{formatTimestamp(currentPrice.timestamp)}}
      </div>
    </div>
  </div>
</template>

<script>
  export default {
    name: "PercentChange",
    computed: {
      percentageIncrease() {
        return this.$store.getters.percentageIncrease;
      },
      currentPrice() {
        return this.$store.getters.currentPrice;
      }
    },
    methods: {
      formatTimestamp: timestamp => {
        const currentDate = new Date(timestamp);
        return currentDate.toString().substring(16, 24);
      }
    }
  };
</script>
```

Here, we have two computed properties to return the current Bitcoin price and percentage increase from the store. We also include a method to format the timestamp of each Bitcoin price update for display within our template.

#### PriceItem Component

This component displays a Bitcoin price update and the time the update was recorded

![PriceItem Component](images/priceitem.png)

Still in the components folder, create a file named `PriceItem.vue` and enter the code below:

```markup
<template>
  <li class="list-group-item">
    <div class="row">
      <div class="col-8">${{formatPrice(price.amount)}}</div>
      <div class="col-4 text-right">{{formatTimestamp(price.timestamp)}}</div>
    </div>
  </li>
</template>


<script>
  export default {
    name: "PriceItem",
    props: {
      price: Object
    },
    methods: {
      formatTimestamp: timestamp => {
        const date = new Date(timestamp);
        return date.toString().substring(16, 24);
      },
      formatPrice: amount => {
        return amount.toFixed(2);
      }
    },
  };
</script>
```

In this component, we create a `props` object with a `price` property as this component will require a price object to be passed to it for display within it. We also create two methods to help format the price and time for display.

Great, now we have all the components required for this application. The next thing to do is put everything together under one main component.

#### The Vue App

Inside the `src` folder, open up the `App.vue` file and replace the code in it with the following code:

```javascript
<template>
  <div id="app" class="container">
    <div class="row">
      <div class="col-12">
        <h1>Dashboard</h1>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-6">
        <CoinPrice/>
      </div>
      <div class="col-sm-6">
        <PercentChange/>
      </div>
    </div>
    <div class="row mt-3">
      <div class="col-sm-12">
        <div class="card">
          <div class="card-header">
            Bitcoin Pricing History
          </div>
          <ul class="list-group list-group-flush">
            <PriceItem v-bind:key="price.timestamp" v-for="price in prices" v-bind:price="price"/>
          </ul>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
  //Components
  import CoinPrice from "./components/CoinPrice.vue";
  import PercentChange from "./components/PercentChange.vue";
  import PriceItem from "./components/PriceItem.vue";

  //Store
  import store from "./store";
  import {actions} from "./store";

  export default {
    name: "app",
    components: {
      CoinPrice,
      PercentChange,
      PriceItem
    },
    store,
    computed: {
      prices() {
        return store.state.prices;
      }
    },
    created: function () {
      setInterval(this.triggerNewPrice, 3000);
    },
    methods: {
      triggerNewPrice: () => {
        const diff = (Math.random() - Math.random()) * 10;
        const randomNewPrice = store.getters.currentPrice.amount + diff;
        store.commit(actions.UPDATE_PRICE, {
          amount: randomNewPrice,
          timestamp: Date.now()
        });
      }
    }
  };
</script>

<style>
  @import "../node_modules/bootstrap/dist/css/bootstrap.min.css";
  @import "../node_modules/@fortawesome/fontawesome-free/css/all.min.css";

  #app {
    font-family: "Avenir", Helvetica, Arial, sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    color: #2c3e50;
    margin-top: 60px;
  }
</style>
```

In our `<template>` section we create the Bitcoin dashboard where we make use of our components, looping over the `PriceItem` component to show a history of Bitcoin price updates.

In our `<script>` section, we first import all our components. Then we import our `store` and `actions`, we then create our `App` component by importing the components used in our app;

```javascript
components: {
  CoinPrice,
  PercentChange,
  PriceItem
},
```

then we import our store;

```javascript
...
store,
...
```

importing our store this way makes it automatically available to all child components of our `App` component.

We then create a computed property `prices` to return prices from our store state.

Next we hook into one of the lifecycle hooks of Vuejs components, `created`. This function runs after an instance of the component is created. Inside this function we run one of the methods of our component, `triggerNewPrice`, every three (3) seconds.

The `triggerNewPrice` method is declared inside our `methods` object. The method simply generates a random new price and calls the store's `commit` method with the action to mutate the state and the new random price as the payload, resulting in a new price being added to the state's `prices` array.

In the `<style>` section we simply import `bootstrap` and `fontawesome` css files for use in our application and also add a few styles for aesthetics.

Great! We are done with our application. Now for the moment of truth. Running it.

### Running the Application

To run the application, simply run

`npm run serve`

Open up your browser to load the provided url. You should see the app running successfully and the prices updating on the prices history and across components every three (3) seconds. The percentage difference and price difference also updates.

## Conclusion

Just like Vue, Vuex offers a very clean, easy to use and declarative API for managing state in our applications. Its simplicity does not take anything away from its effectiveness in managing state in our applications regardless of how complex the application is.
